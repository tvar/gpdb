create extension if not exists gp_inject_fault;
create or replace function test_consume_xids(int4) returns void
as '@abs_srcdir@/regress.so', 'test_consume_xids'
language C;
set debug_burn_xids=on;
-- Autovacuum should take care of anti-XID wraparounds of 'template0'. Because
-- of that, the age of template0 should not go much above
-- autovacuum_freeze_max_age (we assume the default of 200 million here).
select age(datfrozenxid) < 200 * 1000000 from pg_database where datname='template0';
 ?column? 
----------
 t
(1 row)

-- track that we've updated the row in pg_database for template0
SELECT gp_inject_fault('vacuum_update_dat_frozen_xid', 'skip', 1);
NOTICE:  Success:
 gp_inject_fault 
-----------------
 t
(1 row)

-- Autovacuum is triggered after autovacuum_freeze_max_age and on 64K boundaries.
select test_consume_xids(200 * 1000000);
 test_consume_xids 
-------------------
 
(1 row)

select test_consume_xids(64 * 1024);
 test_consume_xids 
-------------------
 
(1 row)

-- wait until autovacuum worker updates pg_database
SELECT gp_inject_fault('vacuum_update_dat_frozen_xid', 'wait_until_triggered', 1);
NOTICE:  Success:
 gp_inject_fault 
-----------------
 t
(1 row)

SELECT gp_inject_fault('vacuum_update_dat_frozen_xid', 'reset', 1);
NOTICE:  Success:
 gp_inject_fault 
-----------------
 t
(1 row)

-- Wait until autovacuum commits the pg_database change
-- Or timeout after 30 seconds
do $$
begin
  for i in 1..300 loop
    if (select age(datfrozenxid) < 200 * 1000000 from pg_database where datname='template0') then
      raise notice 'template0 is young again';
      return;
    end if;
    perform pg_sleep(0.1);
  end loop;
  raise notice 'FAIL: template0 is not being frozen!';
end;
$$;
NOTICE:  template0 is young again
-- template0 should be young
select age(datfrozenxid) < 200 * 1000000 from pg_database where datname='template0';
 ?column? 
----------
 t
(1 row)

-- But autovacuum should not touch other databases. Hence, our database
-- should be well above the 200 million mark.
select age(datfrozenxid) > 200 * 1000000 from pg_database where datname=current_database();
 ?column? 
----------
 t
(1 row)

-- There is a limit of one billion transactions due to xid_stop_limit
-- Let's vacuum to clean up after ourselves to make future tests or multiple runs more reliable.
\c regression;
VACUUM FREEZE;
\c template1;
VACUUM FREEZE;
\c postgres;
VACUUM FREEZE;
